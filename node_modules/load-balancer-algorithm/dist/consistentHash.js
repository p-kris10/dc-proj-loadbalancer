"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsistentHash = void 0;
const crypto_1 = __importDefault(require("crypto"));
const base_1 = require("./base");
const NUM = 128;
class ConsistentHash extends base_1.Base {
    reset(pool) {
        const nodeList = super.reset(pool);
        this._virtualNodes = new Map();
        if (nodeList) {
            for (const address of nodeList) {
                for (let i = 0; i < NUM / 4; i++) {
                    const digest = this._digest(`${address}${i}`);
                    for (let h = 0; h < 4; h++) {
                        // virtual nodes
                        const m = this._hash(digest, h);
                        this._virtualNodes.set(m, address);
                    }
                }
            }
        }
        this._sortKeys = Array.from(this._virtualNodes.keys()).sort((a, b) => a - b);
        return nodeList;
    }
    /**
     * convert byte to int
     * @param digest
     * @param index
     */
    _hash(digest, index) {
        const f = (digest[3 + index * 4] << 24) |
            (digest[2 + index * 4] << 16) |
            (digest[1 + index * 4] << 8) |
            digest[index * 4];
        return f & 0xffffffff;
    }
    _digest(value) {
        const md5 = crypto_1.default.createHash("md5");
        return md5.update(value, "utf8").digest("hex").toString();
    }
    _selectForKey(hash) {
        const len = this._sortKeys.length;
        let key = this._sortKeys[0];
        if (this._sortKeys[len - 1] >= hash) {
            for (let i = len - 1; i >= 0; i--) {
                if (this._sortKeys[i] < hash) {
                    key = this._sortKeys[i + 1];
                    break;
                }
            }
        }
        return this._virtualNodes.get(key);
    }
    _buildKeyOfHash(args) {
        if (!args || !args.length)
            return "";
        return JSON.stringify(args[0]);
    }
    pick(args) {
        const key = this._buildKeyOfHash(args);
        const digest = this._digest(key);
        return {
            host: this._selectForKey(this._hash(digest, 0)),
            args
        };
    }
}
exports.ConsistentHash = ConsistentHash;
//# sourceMappingURL=consistentHash.js.map